<!--
 * @Author: hudingyu
 * @Date: 2020-03-08 22:26:59
 * @LastEditTime: 2020-04-15 18:09:28
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /backend-series/数据持久化.md
 -->

 ### Redis持久化
 
 #### 两种持久化方法
 1. RDB: 快照（snapshotting），它可以将存在于某一时刻的所有数据都写入硬盘里面；
 2. AOF: 只追加文件（append-only file, AOF)，它会在执行写命令时，将被执行的写命令复制到硬盘里面。

#### RDB
RDB文件适合数据的容灾备份与恢复，通过RDB文件恢复数据库耗时较短，可以快速恢复数据。

##### SAVE和BGSAVE
SAVE是阻塞式持久化，执行命令时Redis主进程把内存数据写入到RDB文件中直到创建完毕，期间Redis不能处理任何命令。

BGSAVE属于非阻塞式持久化，创建一个子进程把内存中数据写入RDB文件里同时主进程处理命令请求。

快照持久化 可以完全交给 子进程 来处理，父进程 则继续 处理客户端请求。子进程 做数据持久化，它 不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是 父进程 不一样，它必须持续服务客户端请求，然后对 `内存数据结构进行不间断的修改`。

这个时候就会使用操作系统的 `COW 机制`来进行 `数据段页面` 的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复
制一份分离出来，然后 `对这个复制的页面进行修改`。这时 子进程 相应的页面是 没有变化的，还是进程产生时那一瞬间的数据。

子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化 叫「快照」的原因。接下来子进程就可以非常安心的遍历数据了进行序列化写磁盘了。




##### 创建快照时机

1. 客户端可以通过向Redis发送BGSAVE命令来创建一个快照。Redis会调用fork来创建个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。
2. 客户端还可以通过向Redis发送SAVE命令来创建一个快照，接到SAVE命令的Redis服务器在快照创建完毕之前将不再响应任何其他命令。
3. 如果用户在redis.conf中设置了save配置选项，那么当任意一个save配置选项所设置的条件被满足时，Redis就会触发一次BGSAVE命令。
4. 当Redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在SAVE命令执行完毕之后关闭服务器。
5. 当一个Redis服务器连接另一个Redis服务器，并向对方发送SYNC命令来开始一次复制操作的时候，如果主服务器目前没有在执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器就会执行 BGSAVE命令。
##### 优缺点
优点
   - 通过RDB文件恢复数据库耗时较短，可以快速恢复数据；
   - RDB文件是经过压缩的，占用的空间会小于内存中的数据大小。

缺点
   - 如果发生宕机，采用RDB的方式会丢失最后一次生成快照之后所有的写入的所有数据；
   - 使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求；
   - 使用bgsave命令在forks子进程时可能发生阻塞。



#### AOF
与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。

##### 开启AOF持久化方式

Redis默认不开启AOF持久化方式，可以在配置文件中开启并进行更加详细的配置，如下面的redis.conf文件：
```
# 开启aof机制
appendonly yes

# aof文件名
appendfilename "appendonly.aof"

# 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或no, 默认everysec
appendfsync always

# 默认不重写aof文件
no-appendfsync-on-rewrite no

# 保存目录
dir ~/redis/
```

##### AOF文件重写
AOF将客户端的每一个写操作都追加到aof文件末尾，比如对一个key多次执行incr命令，这时候，aof保存每一次命令到aof文件中，aof文件会变得非常大。

aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决这个问题，Redis支持aof文件重写，移除AOF文件中的冗余命令来重建AOF文件，使AOF文件的体积变得尽可能地小。

通过在redis.conf配置文件中的选项no-appendfsync-on-rewrite可以设置是否开启重写，这种方式会在**每次fsync时都重写**，影响服务器性能，因此默认值为no，不推荐使用。

客户端可以向服务器发送`bgrewriteaof`命令，也可以让服务器进行AOF重写。

AOF重写方式也是**异步操作**，即如果要写入aof文件，则Redis主进程会forks一个子进程来处理。Redis 提供了 bgrewriteaof 指令用于对 AOF 日志进行瘦身。其 原理 就是 开辟一个子进程 `对内存进行 遍历 转换成一系列 Redis 的操作指令`，序列化到一个新的 AOF 日志文件 中。序列化完毕后再将`操作期间发生的 增量 AOF 日志 追加到这个新的 AOF 日志文件`中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。

子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 会出现数据库的数据和重写后的 AOF 文件中的数据不一致。因此Redis 增加了一个**AOF重写缓存**， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中。

当重完操作完成后，会将所有缓冲区中的日志一次性写入到临时文件中。然后调用原子性的rename命令用新的 AOF文件取代老的AOF文件。
 
整个 AOF 后台重写过程中**只有最后写入缓存和改名操作会造成主进程阻塞**， 在其他时候AOF 后台重写都不会对主进程造成阻塞， 将 AOF 重写对性能造成的影响降到了最低。


##### 注意事项

如果用户在运行redis-check-aof程序时给定了`--fix`参数，那么程序将对AOF文件进行修复。程序修复AOF文件的方法非常简单：它会扫描给定的AOF文件，寻找不正确或者不完整的命令，当发现第一个出错命令的时候，程序会删除出错的命令以及位于出错命令之后的所有命令，只保留那些位于出错命令之前的正确命令。




##### 优缺点
优点
- AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。
- 发生宕机时，丢失的数据较少。

缺点

- AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大；
- 会对写的 QPS 有所影响，相对于 RDB 来说 写 QPS 要下降；
- 恢复数据的速度比RDB慢。


#### Redis的数据恢复

##### Redis的数据恢复优先级
1、如果只配置 AOF ，重启时加载 AOF 文件恢复数据；

2、如果同时配置了 RDB 和 AOF ，启动只加载 AOF 文件恢复数据；

3、如果只配置 RDB，启动将加载 dump 文件恢复数据。

拷贝 AOF 文件到 Redis 的数据目录，启动 redis-server AOF 的数据恢复过程:Redis 虚拟一个客户端，读取AOF文件恢复 Redis 命令和参数，然后执行命令从而恢复数据，这些过程主要在loadAppendOnlyFile() 中实现。

拷贝 RDB 文件到 Redis 的数据目录，启动 redis-server即可，因为RDB文件和重启前保存的是真实数据而不是命令状态和参数。


##### 新型的混合型持久化

```
aof-use-rdb-preamble yes
```
RDB和AOF都有各自的缺点：
- RDB是每隔一段时间持久化一次, 故障时就会丢失宕机时刻与上一次持久化之间的数据，无法保证数据完整性；
- AOF存储的是指令序列, 恢复重放时要花费很长时间并且文件更大


Redis 4.0 提供了更好的**混合持久化**选项： 创建出一个同时包含 RDB 数据和 AOF 数据的 AOF 文件， 其中 RDB 数据位于 AOF 文件的开头， 它们储存了服务器开始执行重写操作时的数据库状态，至于那些在重写操作执行之后执行的 Redis 命令， 则会继续以 AOF 格式追加到 AOF 文件的末尾， 也即是 RDB 数据之后。












 
