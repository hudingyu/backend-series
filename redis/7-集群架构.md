<!--
 * @Author: hudingyu
 * @Date: 2020-03-20 18:57:08
 * @LastEditTime: 2020-04-02 18:19:45
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /backend-series/redis/集群架构.md
 -->
 ### 主从模式
 
  ##### 实现主从复制的两种方式
  - slaveof命令
  从服务器执行 `slaveof` 命令
  
  > 建立主从命令：slaveof ip port  
  > 取消主从命令：slaveof no one
  
  - redis.conf配置文件配置
  > 格式：slaveof ip port  
  > 从节点只读：slave-read-only yes #配置只读

  ##### 主从结构作用
  - 冗余备份  
  当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障
  
  - 读写分离  
  主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。

 ### 哨兵模式

 在主从模式下如果Master宕机，需要手动重启Master节点或者手动切换主节点来完成系统恢复，这在生产环境中是有问题的。

 Sentinel（哨兵）进程监控Redis集群中Master主服务器工作的状态，**在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换**，保证系统的高可用。

 
- 哨兵（Sentinel）是一个分布式系统，你可以在一个架构中运行多个哨兵进程，这些进程使用**流言协议**（Gossip Protocols）来接收关于Master主服务器是否下线的信息，并使用**投票协议**（Agreement Protocols）来决定是否执行自动故障迁移，以及选择哪个Slave作为新的Master。
- 主观宕机：每个哨兵（Sentinel）进程会向其它哨兵、Master、Slave定时发送消息，以确认对方是否”活”着。如果发现Master在指定配置时间内未得到回应，则暂时认为对方已掉线，也就是所谓的主观宕机（Subjective Down，SDOWN）。
- 客观宕机：当“哨兵群”中的多数Sentinel进程在对Master主服务器做出SDOWN的判断，并且通过SENTINEL is-master-down-by-addr命令互相交流之后，得出的Master Server下线判断，这种方式就是客观宕机（Objectively Down， 简称 ODOWN）。
- 投票：当客观宕机后，哨兵可以通过一定的Vote算法，从剩下的Slave从服务器节点中，选一台提升为Master服务器节点，然后自动修改相关配置，并开启故障转移（failover）。

##### 哨兵进程的作用：

- 监控：哨兵会不断地检查你的Master和Slave是否运作正常。
- 提醒：当被监控的某个Redis节点出现问题时，哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。
- 自动故障迁移：当一个Master不能正常工作时，哨兵会开始一次自动故障迁移操作，它会将失效Master的其中一个Slave升级为新的Master，并让失效Master的其他Slave改为复制新的Master；当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。

 ### 集群模式
![](/redis/assets/redis-cluster.png)
 集群中的每一个 Redis 节点都 互相两两相连，客户端任意 直连 到集群中的 任意一台，就可以对其他 Redis 节点进行 读写 的操作。

 ##### 原理

Redis 集群中内置了 `16384` 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 集群的配置信息，当客户端具体对某一个 key 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 16384  求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，Redis 会根据节点数量 `大致均等` 的将哈希槽映射到不同的节点。

再结合集群的配置信息就能够知道这个 key 值应该存储在哪一个具体的 Redis 节点中，如果不属于自己管，那么就会`使用一个特殊的 MOVED 命令来进行一个跳转，告诉客户端去连接这个节点以获取数据`

##### 集群的主要作用

1、数据分区： 数据分区 (或称数据分片) 是集群最核心的功能。集群将数据分散到多个节点，`一方面` 突破了 Redis `单机内存大小的限制`，存储容量大大增加；`另一方面` 每个主节点都可以对外提供读服务和写服务，大大`提高了集群的响应能力`。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，bgsave 和 bgrewriteaof 的 **fork 操作可能导致主进程阻塞**，主从环境下**主机切换时可能导致从节点长时间无法提供服务**，全量复制阶段**主节点的复制缓冲区可能溢出**……

2、高可用： 集群支持主从复制和主节点的 自动故障转移 （与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。

##### 节点之间的通信机制

###### 两个端口
在 `哨兵系统` 中，节点分为 `数据节点 和 哨兵节点`：前者存储数据，后者实现额外的控制功能。在 `集群` 中，没有数据节点与非数据节点之分：所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点，都提供了两个 TCP 端口：

- 普通端口： 即我们在前面指定的端口 (7000等)。普通端口主要用于为客户端提供服务 （与单机节点类似）；但在节点间数据迁移时也会使用。
- 集群端口： 端口号是普通端口 + 10000 （10000是固定值，无法改变），如 7000 节点的集群端口为 17000。集群端口只用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。

###### Gossip 协议
节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。重点是广播和 Gossip 的对比。

- 广播是指向集群内所有节点发送消息。优点 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，缺点 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。
- Gossip 协议的特点是：在节点数量有限的网络中，**每个节点都 “随机” 的与部分节点通信** （并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 优点 `有负载 (比广播) 低、去中心化、容错性高` (因为通信有冗余) 等；缺点 主要是集群的`收敛速度慢`。





 

 
