<!--
 * @Author: your name
 * @Date: 2020-03-27 16:44:14
 * @LastEditTime: 2020-04-06 20:53:24
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /backend-series/操作系统/操作系统.md
 -->

### 协程与线程

- 多个协程可由一个或多个线程管理，协程的调度发生在其所在的线程中。
  
  多个协程可以运行在同一个线程里面。它们的调度不是线程的切换，而是**纯应用态的协程调度**。
- 可以被调度，调度策略由应用层代码定义，即可被高度自定义实现。
- 执行效率高，占用内存少。
  
  因为`协程的调度切换不是线程切换`，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。`调度发生在应用态而非内核态`。

  内存的花销，使用其所在的线程的内存，意味着线程的内存可以供多个协程使用。

  其次协程的调度`不需要多线程的锁机制`，因为只有一个线程，也`不存在同时写变量冲突`，所以执行效率比多线程高很多。

  ![](/Golang/goroutine&thread.png)


  
#### 2、进程的状态与转换

**运行状态**：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。

**就绪状态**：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。

**阻塞状态**，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。

`注意区别就绪状态和等待状态`：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。

就绪状态 -> 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。

运行状态 -> 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。

运行状态 -> 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。

阻塞状态 -> 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。

#### 3、进程与线程的区别
进程：进程是进程实体的运行过程，是系统进行`资源分配和调度`的一个独立单位（具有动态、并发、独立、异步的特性，以及就绪、执行、阻塞3种状态）；引入进程是为了使多个程序可以并发的执行，以提高系统的资源利用率和吞吐量。

线程：是比进程更小的可独立运行的基本单位，可以看做是轻量级的进程（具有轻型实体，独立调度分派单位，可并发执行，**共享进程资源**等属性）；引入目的是为了减少程序在并发执行过程中的开销，使OS的并发效率更高。

#### 4、进程同步

多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。**进程同步的任务就是对多个相关进程`在执行顺序上进行协调`，使并发执行的多个进程之间可以有效的共享资源和相互合作**，保证程序执行的可再现性

同步机制需要遵循的原则：

- 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请
- 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问
- 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等
- 让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等

#### 5、用户态和核心态

当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；

反之，当程序运行在级特权级上时，就可以称之为运行在内核态。

虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。

当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。

用户态切换到内核态的3种方式

1) 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

2) 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

3) 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

#### 死锁

死锁产生的必要条件：

- 互斥条件:进程对所分配的资源进行排他性的使用
- 请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源
- 不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺
- 环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链


#### 基本分页储存管理方式

把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。

因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要`一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射`。

由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。

#### 基本分段储存管理方式

分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。

分段内存管理当中，地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。

**`线性地址`**: 程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址可以再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。