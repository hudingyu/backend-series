<!--
 * @Author: your name
 * @Date: 2020-04-13 15:46:01
 * @LastEditTime: 2020-04-13 16:05:19
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /backend-series/MySQL/索引.md
 -->
 [MySQL索引](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483701&idx=1&sn=bd229dd584f51ef4fe545d44ad8cdbf9&chksm=979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4&mpshare=1&scene=1&srcid=0409Tn66UYWSWvqEVlOpwGtR&key=6cd553e86912686a47d76f2d900b1b5b388c90b29708f016db3a6e1bcebe032220ba63626095c4298f32cda7d0d7bd11bded2365f05c32e522584dd149b98db0bb8549ef144cdca694665d31d35cfeef&ascene=0&uin=MzAzMjU4NDM3Nw%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.12.4+build(16E195)&version=12020810&nettype=WIFI&lang=zh_CN&fontScale=100&pass_ticket=YHEmqDDX8hHkj5FiSVpQvjYqIMBDHHDS2po4mfJe%2BqIXlqwJI%2Bg7aJUZq0%2BDwGJ0)

 #### InnoDB 索引方案

 `record_type`属性，它的各个取值代表的意思如下：

- 0：普通的用户记录
- 1：目录项记录
- 2：最小记录
- 3：最大记录

**目录项记录**和**普通的用户记录**的不同点：

- 目录项记录的record_type值是1，而普通用户记录的record_type值是0。
- 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。

数据页都存放到B+树这个数据结构中了，所以我们也把我们的数据页称为节点。从图中可以看出来，我们的**实际用户记录其实都存放在B+树的最底层的节点**上，这些节点也被称为叶子节点或叶节点，其余的节点都是用来存放目录项的，这些节点统统被称为内节点或者说非叶节点。其中最上边的那个节点也称为根节点。

##### 聚簇索引

主键建立的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1、使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

  - 页内的记录是按照主键的大小顺序排成一个`单向链表`。
  - 各个存放用户记录的页也是根据页中记录的主键大小顺序排成一个`双向链表`。
  - 各个存放目录项的页也是根据页中记录的主键大小顺序排成一个双向链表。

2、B+树的叶子节点存储的是`完整的用户记录`。
所谓完整的用户记录，就是指这个记录中存储了所有列的值。

我们把具有这两种特性的B+树称为`聚簇索引`，所有完整的用户记录都存放在这个聚簇索引的`叶子节点`处。这种聚簇索引并不需要我们在MySQL语句中显式的去创建，InnoDB存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据。

##### 二级索引

比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树。

这个B+树与上边介绍的聚簇索引有几处不同：

- 使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：

  - 页内的记录是按照c2列的大小顺序排成一个单向链表。

  - 各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表。

  - 各个存放目录项的页也是根据页中记录的c2列大小顺序排成一个双向链表。

- B+树的叶子节点存储的并不是完整的用户记录，而只是`c2列+主键`这两个列的值。

- 目录项记录中不再是`主键+页号`的搭配，而变成了`c2列+页号`的搭配。


#### MyISAM中的索引方案

MyISAM的索引方案虽然也使用B+树，但是却将索引和数据分开存储：

- 将表中的记录按照`插入时间顺序`的存储在一块存储空间上，我们可以通过`行号`而快速访问到一条记录（因为index_demo表的记录是定长的，所以可以使用行号来进行快速访问，对于变长的记录MyISAM有不同的处理方案，我们这里就不介绍了）。
  
  由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。

- MyISAM会单独为表的主键创建一个B+树索引，只不过在B+树的叶子节点中存储的不是完整的用户记录，而是`主键值 + 行号`的组合。也就是**先通过索引找到对应的行号，再通过行号去找对应的记录**！

  这一点和InnoDB是完全不相同的，在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引`全部都是二级索引`！

- 如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和InnoDB中的索引是一样的，只不过在叶子节点处存储的是相应的`列 + 行号`而已。这些索引也全部都是二级索引。
