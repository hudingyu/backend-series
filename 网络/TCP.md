<!--
 * @Author: your name
 * @Date: 2020-03-26 17:04:20
 * @LastEditTime: 2020-04-15 00:07:32
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /backend-series/网络/TCP.md
 -->
https://juejin.im/post/5e38160a6fb9a07c7c2d4e78#heading-9
https://juejin.im/post/5e527c58e51d4526c654bf41#heading-0

1、 TCP和UDP的主要特点对比

UDP 的主要特点

- UDP 是无连接的；
- UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
- UDP 是面向报文的；
- UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；
- UDP 支持一对一、一对多、多对一和多对多的交互通信；
- UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

TCP 的主要特点
TCP 有三大核心特性:


- 面向连接。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。


- 可靠性。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。


  TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是**有状态**。
  
  当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是**可控制**。
相应的，UDP 就是无状态, 不可控的。

- 面向字节流。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。


### 流量控制

所谓流量控制，主要是接收方传递信息给发送方，使其不要发送数据太快，是一种端到端的控制。主要的方式就是**返回的ACK中会包含自己的接收窗口的大小**，并且利用大小来控制发送方的数据发送。

##### 流量控制过程
这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家理解。
首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。

假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解。
现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。

注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。
因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。

此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节。

![](/网络/流量控制.png)

这里面涉及到一种情况，如果B已经告诉A自己的缓冲区已满，于是A停止发送数据；等待一段时间后，B的缓冲区出现了富余，于是给A发送报文告诉A我的rwnd大小为400，但是这个报文不幸丢失了，于是就出现A等待B的通知||B等待A发送数据的死锁状态。为了处理这种问题，TCP引入了**持续计时器（Persistence timer）**，当A收到对方的零窗口通知时，就启用该计时器，时间到则**发送一个1字节的探测报文**，对方会在此时回应自身的接收窗口大小，如果结果仍未0，则重设持续计时器，继续等待。

### 拥塞控制

上一节所说的流量控制发生在发送端跟接收端之间，并没有考虑到**整个网络环境的影响**，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了。而这，也正是拥塞控制需要处理的问题。

#### 拥塞窗口
拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小。
那么之前介绍了接收窗口的概念，两者有什么区别呢？

- 接收窗口(rwnd)是**接收端**给的限制
- 拥塞窗口(cwnd)是**发送端**的限制

限制谁呢？
限制的是发送窗口的大小。
有了这两个窗口，如何来计算发送窗口？
```
发送窗口大小 = min(rwnd, cwnd)
```
取两者的较小值。而拥塞控制，就是来控制cwnd的变化。

#### 慢启动
此阶段的操作：
cwnd设置为一个很小的初始值，这个初始值在不同版本里面是不一样的，有1、3、10等。

在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，`每经过一个 RTT，cwnd 翻倍`。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。

RTT: TCP传输往返时间是指发送端从发送TCP包开始到接收到它的立即响应所耗费的传输时间
​
#### 拥塞避免
此阶段的操作：
收到一个ACK时，cwnd = cwnd + 1/cwnd
当每过一个RTT时，cwnd = cwnd + 1
​此阶段cwnd成线性增长。
跳出该阶段的标志：发生拥塞，此时进入发生拥塞阶段
 
##### 发生拥塞
分为两种情况：

1、RTO超时，重传数据包。TCP认为这种情况网络上很糟糕了，反应也很强烈。

sshthresh =  cwnd /2

cwnd 重置为初始值

进入慢启动过程

2、如果一个包丢失，接收方则对后续的包继续发送针对该包的重传请求。收到3个duplicate ACK，这种情况认为网络情况还可以，反应不是很强烈。

cwnd = cwnd /2

sshthresh = cwnd

进入快速恢复阶段：执行拥塞避免算法

 
#### 快速重传
在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。

比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传。

这就是快速重传，它解决的是是否需要重传的问题。

选择性重传
那你可能会问了，既然要重传，那么只重传第 5 个包还是第5、6、7 个包都重传呢？
当然第 6、7 个都已经到达了，TCP 的设计者也不傻，已经传过去干嘛还要传？干脆记录一下哪些包到了，哪些没到，针对性地重传。

在收到发送端的报文后，接收端回复一个 ACK 报文，那么在这个报文首部的可选项中，就可以加上SACK这个属性，通过left edge和right edge告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。这个过程也叫做选择性重传(SACK，Selective Acknowledgment)，它解决的是如何重传的问题。
#### 快速恢复
当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。
在这个阶段，发送端如下改变：

- 拥塞阈值降低为 cwnd 的一半
- cwnd 的大小变为拥塞阈值
- cwnd 线性增加

#### 为什么快速恢复中会收到多个相同的ack，以及为什么认为收到多个相同ack要比RTO的网络情况好？

这个是tcp的快速重传机制，接收方如果收到的包不连续，从断点开始，每次收到新包，都ack丢失点的序号，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。举例：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。从上面也能看出收到三个相同的2的ack，起码说明网络中还能正常来回传输3，4，5等，说明网络还有的救，所以反应没那么激烈，而RTO说明这段时间不仅仅是2丢了，而且2丢了这段时间还没有收到后面的3个包，所以tcp就认为网络比较糟糕了，反应也比较激烈。










